diff -ur diff/exploitable-experimental/exploitable/lib/analyzers/asan.py exploitable-1.32_rcor-py3.5.egg/exploitable/lib/analyzers/asan.py
--- diff/exploitable-experimental/exploitable/lib/analyzers/asan.py	2015-12-31 16:32:03.000000000 +0100
+++ exploitable-1.32_rcor-py3.5.egg/exploitable/lib/analyzers/asan.py	2018-07-18 13:43:05.295466088 +0200
@@ -65,35 +65,172 @@
 
 from lib.tools import memoized
 
+
 class ASanAnalyzer(object):
-    '''
-    If an analyzer function returns True the rule is considered a match
-    to the GDB inferior's state, otherwise the rule is not considered a match.
-    '''
+
+    def __init__(self, target):
+        self.target = target
 
     # EXPLOITABLE matching methods follow
 
     @memoized
-    def isUseAfterFree(target): 
-        return target.asan_reason == "heap-use-after-free"
+    def isBranchAvNotNearNull(self):
+        return False
+
+    @memoized
+    def isReturnAv(self):
+        return False
+
+    @memoized
+    def isSegFaultOnPcNotNearNull(self):
+        return False
+
+    @memoized
+    def isErrorWhileExecutingFromStack(self):
+        return False
+
+    @memoized
+    def isStackBufferOverflow(self):
+        asan_stack_errs = ["stack-buffer-overflow", "stack-buffer-underflow", "stack-use-after-return",
+                           "stack-use-after-scope", "dynamic-stack-buffer-overflow"]
+        return self.target.asan_reason in asan_stack_errs
+
+    @memoized
+    def isPossibleStackCorruption(self):
+        return False
 
     @memoized
-    def isStackBufferOverflow(target):
-        return target.asan_reason == "stack-buffer-overflow"
-    
-    @memoized
-    def isHeapError(target):
-        asan_heap_errs = ["double-free", "bad-free", "alloc-dealloc-mismatch", "unknown-crash"]
-    
-        return target.asan_reason in asan_heap_errs
+    def isDestAvNotNearNull(self):
+        return False
+
+    @memoized
+    def isHeapError(self):
+        asan_heap_errs = ["double-free", "bad-free", "alloc-dealloc-mismatch", "unknown-crash",
+                            "heap-buffer-overflow", "heap-use-after-free", "global-buffer-overflow",
+                          "use-after-poison", "container-overflow", "intra-object-overflow"]
+        return self.target.asan_reason in asan_heap_errs
 
     # PROBABLY_EXPLOITABLE matching methods follow
 
     @memoized
-    def isDestAv(target):
-        return target.asan_operation == "WRITE"
-    
+    def isStackOverflow(self):
+        return False
+
+    @memoized
+    def isMalformedInstructionSignal(self):
+        return False
+
+    @memoized
+    def isSegFaultOnPcNearNull(self):
+        return False
+
+    @memoized
+    def isBranchAvNearNull(self):
+        return False
+
+    _re_blk_mov = re.compile("^rep.*mov")
+
+    @memoized
+    def isBlockMove(self):
+        return False
+
+    @memoized
+    def isDestAvNearNull(self):
+        return False
+
+    # PROBABLY_NOT_EXPLOITABLE matching methods follow
+
+    @memoized
+    def isBenignSignal(self):
+        return False
+
+    @memoized
+    def isSourceAvNotNearNull(self):
+        return False
+
+    @memoized
+    def isFloatingPointException(self):
+        return self.target.asan_reason == "FPE"
+
+    # UNKNOWN matching methods follow
+
+    @memoized
+    def isSourceAvNearNull(self):
+        return False
+
+    @memoized
+    def isAbortSignal(self):
+        return self.target.asan_reason == "ABRT"
+
+    @memoized
+    def isAccessViolationSignal(self):
+        return self.isSignalInList(["SEGV", "BUS"])
+
+    @memoized
+    def isUncategorizedSignal(self):
+        return self.target.asan_reason in ["UNKNOWN", "NOTRACE"]
+
+    '''
+    Helpers
+    The following functions are called by multiple analyzers and are not 
+    directly associated with a rule.
+    '''
+
+    @memoized
+    def isOnSignal(self):
+        return self.target.asan_reason in ["ABRT", "SEGV", "ILL", "FPE", "BUS"]
+
+    @memoized
+    def isSignalInList(self, siglist):
+        if not self.isOnSignal():
+            return False
+        return self.target.asan_reason in siglist
+
+    def isNearNull(self, addr):
+        return False
+
+    @memoized
+    def isInBacktrace(self, fnames, region=None):
+        return False
+
+    @memoized
+    def isFaNearNull(self):
+        return False
+
+    @memoized
+    def isBenign(self):
+        return False
+
+    @memoized
+    def isJumpInstruction(self):
+        return False
+
+    @memoized
+    def isBranchAv(self):
+        return False
+
+    @memoized
+    def faultingAddress(self):
+        if self.isJumpInstruction():
+            # si_addr does not always contain a valid faulting address, but
+            # jump instructions always access the dest op and GDB always displays
+            # the absolute addr, so we can use the dest op instead of si_addr here.
+            return self.target.current_instruction().operands[0].eval()
+        return self.target.si_addr()
+
+    @memoized
+    def isSegFaultOnPc(self):
+        return False
+
+    @memoized
+    def isDestAv(self):
+        return self.target.asan_operation == "WRITE"
+
+    @memoized
+    def isSourceAv(self):
+        return self.target.asan_operation == "READ"
+
     @memoized
-    def isSourceAv(target):
-         return target.asan_operation == "READ"
+    def isUseAfterFree(self):
+        return self.target.asan_reason == "heap-use-after-free"
 
diff -ur diff/exploitable-experimental/exploitable/lib/classifier.py exploitable-1.32_rcor-py3.5.egg/exploitable/lib/classifier.py
--- diff/exploitable-experimental/exploitable/lib/classifier.py	2015-12-31 16:32:03.000000000 +0100
+++ exploitable-1.32_rcor-py3.5.egg/exploitable/lib/classifier.py	2018-07-18 10:14:36.758643591 +0200
@@ -198,5 +198,6 @@
                     rule.tag, e, traceback.format_exc()))
 
         c.hash = target.hash()
+
         return c
 
diff -ur diff/exploitable-experimental/exploitable/lib/gdb_wrapper/asan.py exploitable-1.32_rcor-py3.5.egg/exploitable/lib/gdb_wrapper/asan.py
--- diff/exploitable-experimental/exploitable/lib/gdb_wrapper/asan.py	2015-12-31 16:32:03.000000000 +0100
+++ exploitable-1.32_rcor-py3.5.egg/exploitable/lib/gdb_wrapper/asan.py	2018-07-19 17:13:41.727303910 +0200
@@ -71,7 +71,8 @@
 
 from lib.tools import AttrDict, memoized
 
-from lib.gdb_wrapper.x86 import Backtrace, Frame, Target, ProcMaps
+from lib.gdb_wrapper.x86 import Backtrace, Frame, Target, ProcMaps, GdbWrapperError
+from lib.gdb_wrapper.elf import read_elf_sects
 
 class ASanFrame(Frame):
     '''
@@ -222,7 +223,7 @@
     Note: This code was contributed by BlackBerry, and has not been thoroughly
     tested outside of their environment.
     ''' 
-    _re_asan_bt = re.compile(r"""^(\033\133[0-9]+m)* # ANSI colour code
+    _re_asan_bt = re.compile(r"""^(\033\133[0-9]+m)? # ANSI colour code
                                   (?P<all>\s*\#(?P<frame>[0-9]+)\s*
                                   (?P<addr>0x[A-Fa-f0-9]+)\s*\()
                                   (?P<img>.*?)
@@ -231,16 +232,19 @@
 #==16758== ERROR: AddressSanitizer: attempting double-free on 0x60040000dff0:
 #==16769== ERROR: AddressSanitizer: heap-use-after-free on address 0x60040000dff0 at pc 0x4025b1 bp 0x7ffff1dbe6c0 sp 0x7ffff1dbe6b8
 #READ of size 1 at 0x60040000dff0 thread T0
-    _re_asan_fault = re.compile(r"""^(\033\133[0-9]+m)* # ANSI colour code
+    _re_asan_fault = re.compile(r"""^(\033\133[0-9]+m)? # ANSI colour code
                                      =+[0-9]+=+\s*ERROR:\s*AddressSanitizer:\s*
                                      (attempting\s)?(?P<desc>[A-Za-z0-9_-]+)\s
                                      on\s((unknown\s)?address\s)?(?P<fault>0x[A-Fa-f0-9]+)
                                      (:$ | \s(\(|at\s)
                                          pc\s(?P<pc>0x[A-Fa-f0-9]+)\s
                                          (?P<bspid1>[bs]p)\s(?P<bsp1>0x[A-Fa-f0-9]+)\s
-                                         (?P<bspid2>[bs]p)\s(?P<bsp2>0x[A-Fa-f0-9]+)([\r\n]+
-                                     (\033\133[0-9]+m)* # ANSI colour code
-                                     (?P<operation>[A-Za-z0-9_-]+))?)""", re.VERBOSE|re.MULTILINE)
+                                         (?P<bspid2>[bs]p)\s(?P<bsp2>0x[A-Fa-f0-9]+)\s
+                                         (T(?P<tid>[0-9]+\)))?([\r\n]+
+                                     (\033\133[0-9]+m)? # ANSI colour code
+                                     =+[0-9]+=+\s*
+                                     (?P<operation>(The\ssignal\sis\scaused\sby\sa\s)?[A-Za-z0-9_-]+
+                                     (\smemory\saccess.)?))?)""", re.VERBOSE|re.MULTILINE)
     _re_asan_report_sym = re.compile(r"^(__asan_report_error|__asan::ReportDoubleFree)")
     _re_asan_printloop = re.compile(r"^(__sanitizer::RawWrite|__sanitizer::Abort|[A-Za-z_0-9]*puts)")
     _re_symline_trim = re.compile(r" starts at address.*\s*")
@@ -248,7 +252,16 @@
     _asan_reasons = ["double-free", "bad-free", "alloc-dealloc-mismatch", "unknown-crash",
                      "heap-buffer-overflow", "global-buffer-overflow", "stack-use-after-scope",
                      "use-after-poison", "stack-use-after-return", "stack-buffer-overflow",
-                     "initialization-order-fiasco", "stack-buffer-underflow", "heap-use-after-free", "SEGV"]
+                     "initialization-order-fiasco", "stack-buffer-underflow", "heap-use-after-free", "SEGV",
+                     "FPE", "ILL", "ABRT", "BUS", "UNKNOWN"]
+
+#     "stack-overflow", "signal", "null-deref", "wild-jump", "wild-addr-write", "wild-addr-read",
+#     "wild-addr", "double-free", "new-delete-type-mismatch", "bad-free", "alloc-dealloc-mismatch",
+# "bad-malloc_usable_size", "bad-__sanitizer_get_allocated_size", "calloc-overflow", \
+# "pvalloc-overflow", "invalid-allocation-alignment", "invalid-aligned-alloc-alignment",
+# "invalid-posix-memalign-alignment", "allocation-size-too-big", "rss-limit-exceeded",
+# "out-of-memory", "negative-size-param", "bad-__sanitizer_annotate_contiguous_container",
+# "odr-violation", "invalid-pointer-pair"]
 
     def __init__(self, asan_output, bt_limit=0):
         self.__memo__ = {"isPossibleStackCorruption()": False,
@@ -260,71 +273,77 @@
 
         # symbolize asan_message
         self.asan_stack = []
-        out = []
-        last = 0
-        all_frames = []
-        maps = self.procmaps()
-        i = 0
-        for m in self._re_asan_bt.finditer(asan_output):
-            frame, addr, img, offset = m.group("frame", "addr", "img", "offset")
-            frame = int(frame)
-            addr = int(addr, 16) #+ 1
-            if img:
-                maps.add_file(img, addr - offset)
-            out.append(asan_output[last:m.end("all")])
-            all_frames.append((frame, addr, offset, img, len(out)))
-            out.append(None)
-            last = m.end()
-	    
-            i += 1
-            if i >= bt_limit:
-                break
-
-        if not all_frames:
-            raise GdbWrapperError("No frames found in address sanitizer log")
-
-        out.append(asan_output[last:])
-        frame = -1
-        for num, addr, offset, img, outpos in all_frames:
-            region = maps.findByAddr(addr)
-            symbol = gdb.execute("info symbol {:#x}".format(addr), False, True)
-            symline = gdb.execute("info line *{:#x}".format(addr), False, True)
-            if symline and symline.startswith("Line"):
-                symline = "\n\t{}".format(self._re_symline_trim.sub("", symline))
-            else:
-                symline = ""
-            symbol_m = self._re_gdb_info_sym.search(symbol)
-            if img:
-                lib = img
-            elif region:
-                lib = region.name
-            else:
-                lib = None
-            if symbol_m is None:
-                sym = None
-                off = offset
-            else:
-                sym = symbol_m.group("sym")
-                off = int(symbol_m.group("off"))
-            if frame == -1:
-                self.asan_pc_img = lib, offset
-            if frame is not None and num > frame:
-                frame = num
-                if lib:
-                    lib = os.path.basename(lib)
-                self.asan_stack.append(AttrDict(addr=addr,
-                                                lib=lib,
-                                                off=off,
-                                                name=sym))
-            else:
-                frame = None
-            out[outpos] = "{}){}".format(ASanFrame.create(self, addr, sym, off).terse(), symline)
-        asan_output = "".join(out)
+        self.bt_limit = bt_limit
+        # out = []
+        # last = 0
+        # all_frames = []
+        # maps = self.procmaps()
+        # i = 0
+        # for m in self._re_asan_bt.finditer(asan_output):
+        #     frame, addr, img, offset = m.group("frame", "addr", "img", "offset")
+        #     frame = int(frame)
+        #     addr = int(addr, 16) #+ 1
+        #     offset = int(offset, 16)
+        #     if img:
+        #         maps.add_file(img, addr - offset)
+        #     out.append(asan_output[last:m.end("all")])
+        #     all_frames.append((frame, addr, offset, img, len(out)))
+        #     out.append(None)
+        #     last = m.end()
+        #
+        #     i += 1
+        #     if i >= bt_limit:
+        #         break
+        #
+        # if not all_frames:
+        #     self.asan_reason = "NOTRACE"
+        # else:
+            # out.append(asan_output[last:])
+            # frame = -1
+            # for num, addr, offset, img, outpos in all_frames:
+            #     region = maps.findByAddr(addr)
+            #     symbol = gdb.execute("info symbol {:#x}".format(addr), False, True)
+            #     symline = gdb.execute("info line *{:#x}".format(addr), False, True)
+            #     if symline and symline.startswith("Line"):
+            #         symline = "\n\t{}".format(self._re_symline_trim.sub("", symline))
+            #     else:
+            #         symline = ""
+            #     symbol_m = self._re_gdb_info_sym.search(symbol)
+            #     if img:
+            #         lib = img
+            #     elif region:
+            #         lib = region.name
+            #     else:
+            #         lib = None
+            #     if symbol_m is None:
+            #         sym = None
+            #         off = offset
+            #     else:
+            #         sym = symbol_m.group("sym")
+            #         off = int(symbol_m.group("off"))
+            #     if frame == -1:
+            #         self.asan_pc_img = lib, offset
+            #     if frame is not None and num > frame:
+            #         frame = num
+            #         if lib:
+            #             lib = os.path.basename(lib)
+            #         self.asan_stack.append(AttrDict(addr=addr,
+            #                                         lib=lib,
+            #                                         off=off,
+            #                                         name=sym))
+            #     else:
+            #         frame = None
+            #     out[outpos] = "{}){}".format(ASanFrame.create(self, addr, sym, off).terse(), symline)
+            # asan_output = "".join(out)
         gdb.write(asan_output)
         gdb.flush()
         # parse ASAN's analysis
         m = self._re_asan_fault.search(asan_output)
         self.__memo__["si_addr()"] = int(m.group("fault"), 16)
+        self.faddr = int(m.group("fault"), 16)
+        self.pc = int(m.group("pc"), 16)
+        self.bp = int(m.group("bsp1"), 16)
+        self.sp = int(m.group("bsp2"), 16)
         self.asan_reason = m.group("desc")
         if self.asan_reason == "double-free":
             self.__memo__["pc()"] = self.asan_stack[1].addr
